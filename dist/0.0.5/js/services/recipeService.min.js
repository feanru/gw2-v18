import { getCached, setCached } from '../utils/cache.js';
import { fetchWithCache } from '../utils/requestCache.js';
import fetchWithRetry from '../utils/fetchWithRetry.js';
import { getPrice, preloadPrices } from '../utils/priceHelper.js';
import { getConfig } from '../config.js';
import { normalizeApiResponse } from '../utils/apiResponse.js';

const MAX_BUNDLE_BATCH = 35;

export async function getItemBundles(ids = []) {
    if (!Array.isArray(ids) || ids.length === 0) return [];

    const results = new Map();
    const toFetch = [];

    ids.forEach(id => {
        const key = String(id);
        const cached = getCached(`bundle_${key}`);
        if (cached) {
            results.set(key, cached);
        } else {
            toFetch.push(key);
        }
    });

    if (toFetch.length > 0) {
        for (let i = 0; i < toFetch.length; i += MAX_BUNDLE_BATCH) {
            const batch = toFetch.slice(i, i + MAX_BUNDLE_BATCH);
            const params = batch.map(id => `ids[]=${id}`).join('&');

            try {
                const response = await fetchWithRetry(`/backend/api/dataBundle.php?${params}`);
                if (!response.ok) {
                    console.error('Error en getItemBundles: respuesta no válida');
                } else {
                    const payload = await response.json().catch(() => null);
                    const { data, meta } = normalizeApiResponse(payload);
                    const entries = Array.isArray(data) ? data : [];
                    if (!Array.isArray(data) && Array.isArray(meta?.errors) && meta.errors.length) {
                        console.warn('dataBundle devolvió errores', meta.errors);
                    }
                    if (entries.length) {
                        entries.forEach(entry => {
                            const entryKey = String(entry.id);
                            results.set(entryKey, entry);
                            setCached(`bundle_${entryKey}`, entry);
                            window.dispatchEvent(new CustomEvent('bundleItemRefreshed', { detail: entry }));
                        });
                    }
                }
            } catch (e) {
                console.error('Error en getItemBundles:', e);
            } finally {
                batch.forEach(id => {
                    const key = String(id);
                    if (!results.has(key)) {
                        results.set(key, null);
                    }
                });
            }
        }
    }

    return ids.map(id => {
        const key = String(id);
        return results.get(key) || null;
    });
}

export async function getRecipesForItem(itemId) {
    const ids = Array.isArray(itemId) ? itemId : [itemId];
    const bundles = await getItemBundles(ids);
    if (Array.isArray(itemId)) {
        return bundles.map(b => (b?.recipe ? [b.recipe] : []));
    }
    const recipe = bundles[0]?.recipe;
    return recipe ? [recipe] : [];
}

export async function getRecipeDetails(recipeId) {
    const cacheKey = `recipe_${recipeId}`;
    const cached = getCached(cacheKey, true);

    try {
        const { API_BASE_URL } = getConfig();
        const response = await fetchWithCache(`${API_BASE_URL}/recipes/${recipeId}`, {}, cacheKey, cached);
        if (!response.ok) {
            return null;
        }

        const recipe = await response.json();
        if (!recipe) {
            return null;
        }
        recipe.lastUpdated = new Date().toISOString();
        const etag = response.headers.get('ETag');
        const lastModified = response.headers.get('Last-Modified');
        setCached(cacheKey, recipe, undefined, { etag, lastModified });
        return recipe;
    } catch (error) {
        console.error('Error en getRecipeDetails:', error);
        return null;
    }
}

export async function getItemDetails(itemId) {
    if (Array.isArray(itemId)) {
        const bundles = await getItemBundles(itemId);
        return bundles.map(b => b?.item || null);
    }
    const bundle = await getItemBundles([itemId]);
    return bundle[0]?.item || null;
}

export async function getItemPrices(itemId) {
    if (Array.isArray(itemId)) {
        const map = await preloadPrices(itemId);
        return itemId.map(id => {
            const p = map.get(id) || {};
            return { buys: { unit_price: p.buy_price || 0 }, sells: { unit_price: p.sell_price || 0 } };
        });
    }
    const p = await getPrice(itemId);
    return { buys: { unit_price: p?.buy_price || 0 }, sells: { unit_price: p?.sell_price || 0 } };
}

const recipeServiceApi = {
    getItemBundles,
    getRecipesForItem,
    getRecipeDetails,
    getItemDetails,
    getItemPrices
};

export function registerRecipeServiceGlobals(target = typeof window !== 'undefined' ? window : undefined) {
    if (!target) {
        return recipeServiceApi;
    }

    const mergedService = {
        ...(target.RecipeService || {}),
        ...recipeServiceApi
    };

    target.RecipeService = mergedService;

    Object.entries(recipeServiceApi).forEach(([name, fn]) => {
        if (typeof target[name] !== 'function') {
            target[name] = fn;
        }
    });

    return mergedService;
}

if (typeof window !== 'undefined') {
    registerRecipeServiceGlobals(window);
}
